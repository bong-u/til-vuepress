# CS (컴퓨터구조)

Microprogramed Control UnitMicroprogrammed control unit의 control memory에 대한 4가지 address sequencing capability에 대해 block diagram을 사용하여 설명하시오.Instruction code -> Mapping logic -> Multiplexers Branch logic MUX select Multiplexers Controller address register (CAR) Control memory -> selet a status bit branch address microoperations Incremeter Subroutine Register (SBR) Mapping logic Instruction code Multiplexers Controler address register(CAR)Address sequencing capability에는 4가지가 있습니다.1.Controler Address Register를 1 증가 시키는 방법Control address register의 값이 Incrementer를 통해 1 증ㄱ하게 되고 이는 Multiplexers로 들어간 다음에 다시 ontrol Address Register로 들어가게 됩니다1.nconditionally Branch하거나 n개의 status bit ondition에 따라 conditionally branch하는 방법 Control memory에서 branch를 위한 condition field와 ranchfield를 읽고, Branch address를 multipleer에 넣은 다음, branch logic에 의해 multiplexers에서 control address register로 들어가게 됩니다.2.Instruction을 mapping해서 control address register에 넣는 방법 Mapping logic에 의해 Instruction code를 mapping해서 control address register에 넣게 됩니다.3.Subroutine call을 통해 branch하고 subroutine register에 저장된 return address로 branch하는 방법 Incrementer로 1증가된 값을 subroutine register에 넣고 control memory에서 branch address를 읽은 후에 branch하게 됩니다. return할 때는 subroutine register의 값을 control address register에 넣게 됩니다.4 Controll Address Register를 1 증가 시키는 방법Controll Address Register의 값이 Incrementer를 통해 1 증가하게 되고 이는 Multiplexers로 들어간 다음에 다시 control address register로 들어가게 됩니다2.Unconditionally branch하거나 n개의 status bit condition에 따라 conditionally branch하는 방법 : Control memory에서 branch를 위한 condition field와 branch field를 읽고 branch address를 multilexer에 넣은 다음 branch logic에 의해 Multiplexers에서 contorll address registerㅇ로 들어가게 됩니다1.Instruction 을 mappingㅇ해서 Controll Address Register에 넣는 방법 : Mapping logic에 의해 Instruction code를 mapping해서 control address register에 넣게 됩니다2.Subroutine call을 통해 branch하고 subroutine register에 저장되는 return address로 branch하는 방법3.Instruction을 mapping해서 Controll Address Register에 넣는 방법 Mapping logic에 의해 Instruction code를 mapping해서 Control address Register에 넣게 됩니다4.subroutine call을 통해 subroutine register에 저장된 return address로 branch하는 방법 Incrementer로 1 증가된 값을 Subroutine Register에 넣고 Control memory에서 branch address를 읽은 후에 branch 하게 됩니다. return 할때는 subroutine register의 값을 control address register에 넣게 됩니다Subroutine call을 통해 branch 하고 subroutine register에 저장된 return address로 branch address를 읽은 후에 branch 하게 됩니다. return할때는 subroutine register의 값을 control address register에 넣게 됩니다.1.control address register를 1증가 시키는 방법 Incrementor를 통해 1 증가 되고 multiplexer로 갔다가 다시 control address registeer2.Unconditionally branch 하거나 n개의 status bit condition에 따라 conditionally branch하는 방법 Control memory에서 branch를 위한 condition filed control field와 branch field를 읽고 branch address를 multiplexer에 넣은 다음 branch logic에 의해 multiplexers 에서 control address register로 들어가게 된다.3.Instruction을 mapping 해서 control address register에 넣는 방법 mapping logic에 의해 instruction code를 mapping해서 control address register에 넣게 됩니다4.subroutine call을 통해 branch하고 subroutine register에 저장된 return address로 branch로 branch하는 방법 incrementor로 1 증가된 값을 subroutine register에 너혹 control memory에서 branch address를 읽은 후에 branch하게 된다. return 할때는 subroutine register의 값을 control address register에 넣게 된다1.Incrementor를 1 증가 시키는 방법2.Unconditionally branch 또는 n 개의 status bit conition에 따라 conditionally branch3.instructino을 mapping 해서 car에 넣는 방법4subroutine call을 통해 branch하고 subroutine register에 저장된 return address로 branch하는 방법 1. Incrementor를 1증가 시키는 방법 2. unconditionally branch 하거나 n개의 status bit condition에 따라 conditionally branch 하는 방법 3. Instruction을 mapping해서 Control Address Register 에 넣는 방법 4. subroutine call을 통해 branch하고 subroutine register에 넣고 subroutine call을 통해 branch하고 subroutine register에 저장된 return address로 branch하는 방법 2. Piepelining k-stage pipeline의 이론적 최대 speedup을 유도하고 ,이러한 이론적 최대 speedup을 얻을 수 없는 이유에 대해 논하시오. k-segment pipeline에서 tp : clock cycle time ,n : number of tasks, tn : time for a nonpipeline unit to complete each task S = ntn / (k+n-1)tp n이 커질 수록 S는 k에 접근 ntn/(k+n-1)tp'k-segment pipelinetp : clock cycle timen : number of taks tn time for nonpipelinng unint to complete each taskS = ntn / (k+n-1) tp 최대 speed-up을 얻을 수 없는 이유 1. 전달시간이 가장 긴 segment의 지연 시간에 맞추어 clock cycle이 정해진다. 2. 일반적으로 nonpiepeline 회로에서는 pipeline에서 사용되는 중간 register들을 사용하지 않고, 전적으로 combinatino circuit으로 구현이 된다. ntn/(k+n-1)tp ntn/k+n-1 n:task의 개수 tp : clock cycle time tn : time for a nonpipeline unit to complete each task S=ntn/(k+n-1)tp tn : non pipeline unit t ocomplete each task clock cycle tim : tp n이 커질 수록 S는 k에 접근한다. 최대 speedup을 얻을 수 없는 이유 1. 전달 시간이 가장 긴 segment의 지연 시간에 맞추어 clock cycle이 정해진다 2. 일반적으로 nonpipeline 회로에서는 pipeline이 사용되는 중간 register들을 사용핮 ㅣ않고 전적으로 combination circuit으로 구현이 된다. 1. 전달시간이 가장 긴 segment에 맞추어 clock cycle이 정해진다 일반적으로 nonpipeline회로에서는 pipeline에서 사용되는 중간 register들을 사용하지 ㅇ낳고 전적으로 combination circuit으로 구현이된다. 전적으로 combination cicuit으로 구현이된다. pipeline에서 사용하는 중간 register들을 사용핮 않고, 3. Instructione pipeline의 문제점  1. 두개의 segment가 동시에 메모리를 access할때 conflict가 발생할 수 잇다. 이러한 conflict는 instructino과 data 메모리 모듈을 분리해서 해결할 수 있습니다.2. 어떤 instruction이 직전 instruction의 수행결과에 의존할 경우 data dependency가 발생핣니다. 2. 어떤 instruction이 직ㅈㄴ instructino의 수행결과에 의존할 경우 data dependency가 발생합니다. 명령어 사이에 no operation을 추가해서 데이터 참조를 지연시켜서 해결 할 수 있다. 2. 어떤 instruction이 직전 instruction의 수행결과에 의존할 경우 data dependency가 발생한다. 명령어 사이에 no operation을 추가해서 데이터 참조를 지연시킨다 3. branch instruction같은 pc 값을 변화시키는 instruction에 의해서 branch가 어렵다. 컴파일러가 branch 앞뒤 명령을 조사해서 프로그램을 재배치한다. 3. Instruction pipeline의 문제점 * instruction pipeline의 경우 일반적인 pipeline 보다 해결보다 할 문제점들이 더욱 많다. 이들 문제점과 해결방법에 대해 자세히 설명하시오. 1. 두 segement 가 동시에 memory에 access하는 경우  conflict가 발생한다. 이러한 conflict는 instruction과 data memory module을 분리해서 해결할 수 있다. 2. 뒤의 명령어가 앞의 명령어에 의존적이라면 data dependency가 발생한다. 명령어 사이에 no operation을 추가해서 데이터 참졸르 지연시켜서 해결할 수 있다.3. branch instruction 같은 pc값을 변화시기키는 instructino에 의해서 branch가 어렵습니다. 컴파일러가 branch 앞뒤 명령을 조사해서 프로그램을 재배치해서 해결 할 수 있다. 1. instruction pipeline의 문제점과 해결방법 1 두 segment가 동시에 memory에 access하는 경우 conflict가 발생한다. 해결방법 : instruction과 data memory moudle을 분리하여 해결 할 수 있다. 2. 앞의 명령어의 결과를 뒤의 명령어가 참조하는 경우 data dependency 가 발생한다. 두 segment사이에 no operation을 추가해서 해결 할 수 있다 3. branch instruction 같은 pc값을 변화시키는 instruction에 의해서 branch가 어렵다 컴파일러가 branch 앞뒤 명령을 조사해서 프로그램을 재배치하면 해결 할 수 있다. 4. Multiplication algorithm multiplication alogirithm 중 booth algorithm에 대해 flowchart를 사용하여 동작 원리를 자세히 설명하시오 Multiply -> Multiplicand in BR, Multiplier in QR -> AC <- 0, Qn+1 <-0, SC<-n, -> QnQn+1 10 -> AC <-AC+BR+1 01 AC<-BR 00, 01 -> Shr(AC&QR) SC<- SC-1 SC -> END 1. microprogrammed control unintㅡ이 control memory에 대한 4가지 address sequencing capability에 대해서 block diagram을 사용하여 설명하시오 Address sequencing capability에는 4가지 방법 1. Control access register의 값을 1 증가시키는 방법  : increamenter를 통해 1w증가하게 되고 multiplixer -> Control access register(car)로 다시 들어간다. 방법 2. Unconditionally branch하거나 n개의 status bit condition에 따라 conditionally branch하는 방법 : control memory에서 branch를 위한 condition field와 branch field를 읽고 branch address를 multiplexer에 넣은 다음 ,branch logic에 의해 multiplexer에서 control address regiseter 로 들어가게 된다 control memory에서 branch를 위한 condition field와 branch field를 읽고, branch address를 multiplexer에 넣으 다음, branch logic에 의해 multiplexers에서 car로 들어가게 된다 3. instructio을 mapping해서 control address register에 넣는 방ㅂㅂ mapping logic에 의해 instruction code를 mapping해서 control address register에 넣게 된다.. 4. subruotine call을 통해 branch하고 subroutine register에 저장된 return address로 branch하는 방법 : incrementor로 1 증가된 값을 subroutine register에 넣었고 control memory에서 branch addresss를 branch하게 됩니다 return 할때는 subroutine register의 값을 car에 넣는다. 2. Unconditionally branch하거나 n개의 status bit condition에 따라 conditionally branch하는 방법 : control memory에서 branch를 위한 condition field와 branch field를 읽고, branch address를 multiplexer에 넣은 다음, branch logic에 의해 multiplexers에서 control address register로 들어가게 됩니다.